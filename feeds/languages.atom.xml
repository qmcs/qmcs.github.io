<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>EECS Society</title><link href="http://eecs.io/" rel="alternate"></link><link href="http://eecs.io/feeds/languages.atom.xml" rel="self"></link><id>http://eecs.io/</id><updated>2014-04-20T00:00:00+01:00</updated><entry><title>Comparing Languages with Quicksort</title><link href="http://eecs.io/comparing-languages-with-quicksort.html" rel="alternate"></link><updated>2014-04-20T00:00:00+01:00</updated><author><name>Filip Ter</name></author><id>tag:eecs.io,2014-04-20:comparing-languages-with-quicksort.html</id><summary type="html">&lt;p&gt;Language speed is often a major factor when determining how useful a programming language can be. Some applications rely on languages that can execute a large amount of instructions in a short amount of time, and programmers may in some cases use languages which have many unpleasant features, just because they can execute an algorithm faster. It would be interesting to see how some languages would fare when it comes to how long it takes them to execute the same algorithm. &lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;I decided to conduct a comparison of programming languages by using them to implement practically the same task and then timing how long each one would take to execute. For the purposes of this article, a faster program is one which can execute an implementation of an algorithm in less time. The algorithm used was quicksort, which is a well-known sorting algorithm invented by Tony Hoare in 1961.&lt;a href="#thoare"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;a id="thoare_back"&gt;&lt;/a&gt; It can be implemented recursively, and it works by finding a pivot value in an array, moving all elements smaller than it to one side and the larger ones to the other, this process is repeated on the sub-sections around the pivot until the whole array is sorted.&lt;/p&gt;
&lt;p&gt;Following up from my previous article, I thought of using the Mersenne Twister&lt;a href="#mt"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;a id="mt_back"&gt;&lt;/a&gt; algorithm to generate random 32bit integers that I would then sort using quicksort in 7 different implementations, specifically: C&lt;a href="#c"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;a id="c_back"&gt;&lt;/a&gt;, C++&lt;a href="#cpp"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;a id="cpp_back"&gt;&lt;/a&gt;, Java&lt;a href="#java"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;&lt;a id="java_back"&gt;&lt;/a&gt;, Python 3&lt;a href="#py"&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;a id="py_back"&gt;&lt;/a&gt;, Python with PyPy&lt;a href="#py"&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;a id="py_back"&gt;&lt;/a&gt;, Jython&lt;a href="#py"&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;a id="py_back"&gt;&lt;/a&gt;, and PHP&lt;a href="#php"&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt;&lt;a id="php_back"&gt;&lt;/a&gt;. For the quicksort algorithm, I found a pseudo-code description of it on Wikipedia&lt;a href="#wiki"&gt;&lt;sup&gt;8&lt;/sup&gt;&lt;/a&gt;&lt;a id="wiki_back"&gt;&lt;/a&gt;. Using a Java implementation of Mersenne Twister&lt;a href="#mtjava"&gt;&lt;sup&gt;9&lt;/sup&gt;&lt;/a&gt;&lt;a id="mtjava_back"&gt;&lt;/a&gt;, I generated 7 files all containing pseudo-random positive 32-bit integers. The files contained 100 to 100 million integers, with each file containing 10 times as many integers as the previous one. Using the description from Wikipedia, I then implemented the algorithm in the languages used in the test, adding functions for reading the numbers from files and printing them for checking.  In the actual test each program was to read the contents of the file, store them in an array, sort the array using quicksort, and finally print a message that the array was sorted. The time of execution would be measured by the Bash time function.&lt;a href="#bashtime"&gt;&lt;sup&gt;10&lt;/sup&gt;&lt;/a&gt;&lt;a id="bashtime_back"&gt;&lt;/a&gt; This was mainly done so that the same function would be measuring all programs, as using timing from different languages can produce unreliable results. In order to obtain more precise results each instance of sorting was done 5 times, and the average time was taken. In an effort to automate the task more, I wrote a Bash script that would run each instance of the program 5 times, time the execution for each run, and then calculate the average of the times and write it to a CSV table.&lt;a href="#bashscript"&gt;&lt;sup&gt;11&lt;/sup&gt;&lt;/a&gt;&lt;a id="bashscript_back"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;As for my initial expectations, they coincided with the usual belief about these languages. I expected the compiled languages(C, C++, Java) to be fast, and the interpreted languages to be slower. This basically follows common knowledge about these languages, but the point of the test is to see how they would actually compare, and how significant the differences would be. When it comes to the Python variants I thought that PyPy would be the fastest out of them as it was designed specifically to make python code run faster, and uses just-in-time(jit) compilation. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The table which contains the average times for all runs of each program, on the five largest files.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;&lt;/th&gt;
            &lt;th colspan="5" align="center"&gt;Seconds taken to sort array&lt;/th&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;th&gt;Language&lt;/th&gt;
            &lt;th&gt;10^4 integers&lt;/th&gt;
            &lt;th&gt;10^5 integers&lt;/th&gt;
            &lt;th&gt;10^6 integers&lt;/th&gt;
            &lt;th&gt;10^7 integers&lt;/th&gt;
            &lt;th&gt;10^8 integers&lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt; 
&lt;tr&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;0.0045&lt;/td&gt;&lt;td&gt;0.0235&lt;/td&gt;&lt;td&gt;0.2115&lt;/td&gt;&lt;td&gt;2.2315&lt;/td&gt;&lt;td&gt;23.4800&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;C++&lt;/td&gt;&lt;td&gt;0.0040&lt;/td&gt;&lt;td&gt;0.0245&lt;/td&gt;&lt;td&gt;0.2130&lt;/td&gt;&lt;td&gt;2.2295&lt;/td&gt;&lt;td&gt;23.4535&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Java&lt;/td&gt;&lt;td&gt;0.2550&lt;/td&gt;&lt;td&gt;0.3735&lt;/td&gt;&lt;td&gt;1.4050&lt;/td&gt;&lt;td&gt;9.9225&lt;/td&gt;&lt;td&gt;95.5925&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Python 3&lt;/td&gt;&lt;td&gt;0.0810&lt;/td&gt;&lt;td&gt;0.4890&lt;/td&gt;&lt;td&gt;5.6820&lt;/td&gt;&lt;td&gt;73.1470&lt;/td&gt;&lt;td&gt;989.4360&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;PyPy2.2.1&lt;/td&gt;&lt;td&gt;0.1320&lt;/td&gt;&lt;td&gt;0.2240&lt;/td&gt;&lt;td&gt;1.5340&lt;/td&gt;&lt;td&gt;9.1640&lt;/td&gt;&lt;td&gt;94.2570&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;PHP&lt;/td&gt;&lt;td&gt;0.1210&lt;/td&gt;&lt;td&gt;0.6650&lt;/td&gt;&lt;td&gt;7.5990&lt;/td&gt;&lt;td&gt;96.5950&lt;/td&gt;&lt;td&gt;1198.0580&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Jython&lt;/td&gt;&lt;td&gt;2.3460&lt;/td&gt;&lt;td&gt;2.8450&lt;/td&gt;&lt;td&gt;9.5880&lt;/td&gt;&lt;td&gt;88.1560&lt;/td&gt;&lt;td&gt;1585.4810&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;A graph which shows the comparison of how long each language took to sort N number of ints, the three largest files are considered&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Graph comparing time taken to sort 100 million integers for 5 languages" src="static/images/lang_graph.png" /&gt;&lt;/p&gt;
&lt;p&gt;The results of this test agree with the general belief that interpreted languages tend to be far slower than compiled ones. C and C++ were almost the same, which could be partly because the same IO libraries were used for those languages. PyPy turned out to be practically 10 times faster than CPython, which was much more than I had expected. This could be because the jit compilation starts making a greater difference with a greater number of integers. Jython was the slowest out of all, which certainly not surprising since it is running Python code on top of the Java Virtual Machine. &lt;/p&gt;
&lt;p&gt;While this test showed interesting outcomes, it leaves many things to be improved. One of these is the heavy use of libraries for file I/O, this means that the test was also measuring the implementation of the libraries, which could have affected the results. For example if a file I/O library in Java was better written than the other ones, it could give that language a skewed advantage. Another issue with this test is that it only considers languages which have their syntax influenced by C, and have many major similarities. It would have been interesting to conduct the test while including languages, which are less similar to one another, for example some of the functional languages.&lt;/p&gt;
&lt;p&gt;If anything this little comparison shows how useful it is to have knowledge of the features of different programming languages. For example, Python is a language which is really pleasant to code in, and allows for elegant solutions, however it would not be a good idea to use it in performance-intensive applications. Knowing about differences like this between different programming languages will allow one to make sensible choices when having to implement a solution to some problem. After all the programming languages we have are just tools, which can be used to implement some solution that the programmer comes up with.&lt;/p&gt;
&lt;h4&gt;Footnotes&lt;/h4&gt;
&lt;p&gt;&lt;a id="thoare"&gt;1&lt;/a&gt;: &lt;a href="http://cs.stanford.edu/people/eroberts/courses/soco/projects/2008-09/tony-hoare/quicksort.html"&gt;http://cs.stanford.edu/people/eroberts/courses/soco/projects/2008-09/tony-hoare/quicksort.html&lt;/a&gt; &lt;a href="#thoare_back"&gt;&amp;#x21a9;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id="mt"&gt;2&lt;/a&gt;: &lt;a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html"&gt;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html&lt;/a&gt; &lt;a href="#mt_back"&gt;&amp;#x21a9;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id="c"&gt;3&lt;/a&gt;: My C implementation of Quicksort (compiled with gcc): &lt;a href="https://github.com/Filip-Ter/QSortTest/blob/master/QsortC.c"&gt;https://github.com/Filip-Ter/QSortTest/blob/master/QsortC.c&lt;/a&gt; &lt;a href="#c_back"&gt;&amp;#x21a9;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id="cpp"&gt;4&lt;/a&gt;: My C++ Quicksort implementation (compiled with g++): &lt;a href="https://github.com/Filip-Ter/QSortTest/blob/master/Qsort.cc"&gt;https://github.com/Filip-Ter/QSortTest/blob/master/Qsort.cc&lt;/a&gt; &lt;a href="#cpp_back"&gt;&amp;#x21a9;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id="java"&gt;5&lt;/a&gt;: My Java Quicksort implementation, complied and executed with jdk 7u51: &lt;a href="https://github.com/Filip-Ter/QSortTest/blob/master/Qsort.java"&gt;https://github.com/Filip-Ter/QSortTest/blob/master/Qsort.java&lt;/a&gt; &lt;a href="#java_back"&gt;&amp;#x21a9;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id="py"&gt;6&lt;/a&gt;: My Python Quicksort implementation, the same source file was used for Python 3.3.4, PyPy, and Jython: &lt;a href="https://github.com/Filip-Ter/QSortTest/blob/master/Qsort.py"&gt;https://github.com/Filip-Ter/QSortTest/blob/master/Qsort.py&lt;/a&gt; &lt;a href="#py_back"&gt;&amp;#x21a9;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id="php"&gt;7&lt;/a&gt;: My PHP Quicksort implementation: &lt;a href="https://github.com/Filip-Ter/QSortTest/blob/master/Qsort.php"&gt;https://github.com/Filip-Ter/QSortTest/blob/master/Qsort.php&lt;/a&gt; &lt;a href="#php_back"&gt;&amp;#x21a9;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id="wiki"&gt;8&lt;/a&gt;:The pseudocode description of the algorithm that is implemented in my programs: &lt;a href="http://en.wikipedia.org/wiki/Quicksort#In-place_version"&gt;http://en.wikipedia.org/wiki/Quicksort#In-place_version&lt;/a&gt; &lt;a href="#wiki_back"&gt;&amp;#x21a9;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id="mtjava"&gt;9&lt;/a&gt;: Java implementation of Mersenne Twister: &lt;a href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/JAVA/MTRandom.java"&gt;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/JAVA/MTRandom.java&lt;/a&gt; &lt;a href="#mtjava_back"&gt;&amp;#x21a9;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id="bashtime"&gt;10&lt;/a&gt;: The bash built-in time function was used, so not /usr/bin/time (GNU time) &lt;a href="#bashtime_back"&gt;&amp;#x21a9;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id="bashscript"&gt;11&lt;/a&gt;: The script used to run and time the programs: &lt;a href="https://github.com/Filip-Ter/QSortTest/blob/master/TestTime.sh"&gt;https://github.com/Filip-Ter/QSortTest/blob/master/TestTime.sh&lt;/a&gt; &lt;a href="#bashscript_back"&gt;&amp;#x21a9;&lt;/a&gt;&lt;/p&gt;</summary><category term="Quicksort"></category><category term="languages"></category><category term="speed"></category></entry><entry><title>A small Markdown introduction</title><link href="http://eecs.io/a-small-markdown-introduction.html" rel="alternate"></link><updated>2014-03-04T00:00:00+00:00</updated><author><name>Henrik O. Skogmo</name></author><id>tag:eecs.io,2014-03-04:a-small-markdown-introduction.html</id><summary type="html">&lt;p&gt;Giving writers a WYSIWYG makes the assumption that they know how to make stuff
look good. This is wrong. People who work with words should only have to care
about words. Leaving the design choices to the designers. Markdown does an
excellent job in accomplishing this compromise.&lt;/p&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;Many of the web's most populare publishing tools are now supporting Markdown.
And you might recognise it from Stack Overflow and GitHub. So maybe it's time
you get down with the M-down?&lt;/p&gt;
&lt;p&gt;How the hell do you harvest the sweet markdown nectar? Easy. Kick-start your
favourite (plain)text editor and fire away. Since Markdown is a lightweight
markup language, all of you oldschool BBCode forum writers out there will find
yourselves quite confortable.&lt;/p&gt;
&lt;p&gt;Even though you can find the reference to &lt;a href="http://daringfireball.net/projects/markdown/syntax"&gt;Markdown's
syntax&lt;/a&gt; online, I'll walk
you through some of the basics. Do note that there is alternatives for some of
the elements, so I encourouge you to gaze over the documenation.&lt;/p&gt;
&lt;h2&gt;Headers&lt;/h2&gt;
&lt;p&gt;Use hashtags to mark the level of a header.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# This is an H1&lt;/span&gt;
&lt;span class="c"&gt;## This is an H2&lt;/span&gt;
&lt;span class="c"&gt;### This is an H3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Emphasis&lt;/h2&gt;
&lt;p&gt;Asterisks or underlines&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;quick&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;brown&lt;/span&gt; &lt;span class="n"&gt;fox&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;jumps&lt;/span&gt; &lt;span class="n"&gt;over&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;lazy&lt;/span&gt; &lt;span class="n"&gt;dog&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Becomes "The quick &lt;em&gt;brown fox&lt;/em&gt; jumps over the &lt;strong&gt;lazy dog&lt;/strong&gt;"&lt;/p&gt;
&lt;h2&gt;Links&lt;/h2&gt;
&lt;p&gt;There are multiple ways of making links in MD, either inline or by reference.
However here is the most used way.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//example.com &amp;quot;Title&amp;quot;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Lists&lt;/h2&gt;
&lt;p&gt;Simply use something that looks listy (*, + or -).&lt;/p&gt;
&lt;h3&gt;Unordered&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Red&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Green&lt;/span&gt;
&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Blue&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Becomes&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Red&lt;/li&gt;
&lt;li&gt;Green&lt;/li&gt;
&lt;li&gt;Blue&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Ordered&lt;/h3&gt;
&lt;p&gt;(What the numbers are does't matter)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mf"&gt;4.&lt;/span&gt; &lt;span class="n"&gt;Red&lt;/span&gt;
&lt;span class="mf"&gt;0.&lt;/span&gt; &lt;span class="n"&gt;Green&lt;/span&gt;
&lt;span class="mf"&gt;4.&lt;/span&gt; &lt;span class="n"&gt;Blue&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Becomes&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Red&lt;/li&gt;
&lt;li&gt;Green&lt;/li&gt;
&lt;li&gt;Blue&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Code&lt;/h2&gt;
&lt;h3&gt;Inline&lt;/h3&gt;
&lt;p&gt;Use the backtick quotes (`) for &lt;code&gt;inline code&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;Block&lt;/h3&gt;
&lt;p&gt;4 spaces or 1 tab indention&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;HAI&lt;/span&gt; &lt;span class="mf"&gt;1.2&lt;/span&gt;
  &lt;span class="n"&gt;CAN&lt;/span&gt; &lt;span class="n"&gt;HAS&lt;/span&gt; &lt;span class="n"&gt;STDIO&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;
  &lt;span class="n"&gt;VISIBLE&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;HAI WORLD!!!1!&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;KTHXBYE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you would like to start using Markdown locally on your own system I have a
couple of Markdown readers to recommend. Even though you don't strickly need
anything fancy to write Markdown, you still need something to parse it.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://mouapp.com/"&gt;Mou&lt;/a&gt; for Mac
&lt;a href="http://markdownpad.com/"&gt;MarkdownPad&lt;/a&gt; for Windowns
&lt;a href="http://sourceforge.net/p/retext/home/ReText/"&gt;ReText&lt;/a&gt; for Linux&lt;/p&gt;</summary><category term="markdown"></category><category term="markup"></category><category term="languages"></category></entry></feed>